---
alwaysApply: true
---

# Projectbasis (Quasar PWA + Vue 3 + TS + PocketBase)
Deze regels definiëren de standaard structuur en stack voor dit project: een Quasar‑gebaseerde Progressive Web App met Vue 3, TypeScript en PocketBase als backend. Gebruik deze leidraad bij het genereren van bestanden, opzet van pagina’s en collections.

Rules:
  • Dit project is een PWA gebouwd met Quasar Framework, Vue 3 en TypeScript.
  • PocketBase is de backend.
  • Capacitor wordt alléén gebruikt voor PWA‑specifieke features, niet voor native apps.
  • Notificaties zijn toegestaan zonder aparte state‑lib.
  • Gebruik Pinia alleen wanneer meerdere componenten gedeelde state nodig hebben (bijv. notificaties of user info).

# Menu‑architectuur (AppMenu vs UserMenu)
Definieert hoe AppMenu en UserMenu zijn gescheiden. Handig voor views en feature‑mappen.

Rules:
  • Layout gebruikt links een QDrawer voor AppMenu en rechts een QDrawer voor UserMenu.
  • Bestanden in mappen plaatsen die de menustructuur volgen (`@/pages/appmenu`, `@/pages/usermenu`).
  • AppMenu‑componenten zijn informatief (read‑only).
  • UserMenu‑componenten zijn voor CRUD.
  • PocketBase collection‑clients in losse files houden en via `index.ts` groeperen.
Tags: @/layouts, @/pages/appmenu, @/pages/usermenu

# Commentaarplicht
Alle gegenereerde code moet duidelijke comments bevatten voor zowel logica als layout, zodat Cursor en andere devs de structuur begrijpen.

---

# Architectuurregels (anti‑duplicatie, hard)
Doel: één waarheid per concern, geen parallelle implementaties.

## Service Worker
  • We gebruiken **uitsluitend** Quasar **PWA GenerateSW** (zie `quasar.config.js > pwa.workboxPluginMode = 'GenerateSW'`).  
  • **Verboden om eigen SW‑bestanden/registraties toe te voegen** (zoals `public/sw.js`, `src-pwa/sw.js`, `src-pwa/custom-service-worker.ts`, of extra `register-service-worker.{js,ts}`). Verwijder bestaande duplicaten en verwijzingen. 

## PocketBase toegangspad
  • UI (pages/components/stores) praten **altijd** via de composable:  
    `const { pb } = usePocketbase();`  
  • Het is **verboden** om `src/config/pocketbase` direct te importeren buiten de composable — dit voorkomt dubbele entrypoints en maakt het later eenvoudiger om Realtime (subscribe) toe te voegen. 

## HTTP‑clients & endpoints
  • Base‑URL’s komen uit **env** (Vite/Quasar), niet hardcoded. Werk dus niet met vaste URLs in `axios` of vergelijkbare clients. Controleer `src/boot/axios.ts` en normaliseer naar env‑variabelen. 

## File‑URL helpers
  • Bouw **nooit** handmatig bestands‑URL’s in components. Gebruik één centrale helper (`src/utils/pocketbase-helpers.ts`) en hergebruik die overal. 

---

# i18n‑standaardisatie (Vue + vue‑i18n)
**Enforce standardized i18n usage in Vue files**

Rules:
  • Importeer altijd `useI18n` uit `vue-i18n` in bestanden die vertalingen gebruiken.  
  • Destructureer altijd `t` als `$customT`:  
    `const { t: $customT } = useI18n();`  
  • In `<template>` en `<script>` gebruik je **altijd** `$customT('key')`. `$t('key')` en bare `t('key')` zijn **verboden**.  
  • Importeer `$customT` nooit direct uit modules.  
  • Ontbreekt `$customT` in een file met vertalingen? Voeg de destructure toe in `<script setup>`.  
  • Auto‑rewrite bij generatie: vervang `$t(` en `t(` door `$customT(`.  
  • Zorg dat `src/types/vue.d.ts` correcte type‑augmentatie voor `$customT` bevat.  
  • Valideer dat keys bestaan in **zowel** `nl.json` als `en.json` en meld ontbrekende keys.
Tags: @/boot/i18n, @/i18n, @/types/vue

**Always apply i18n translations with English as fallback**

Enforcement:
  1) Bij genereren/wijzigen van components:
     • Detecteer user‑facing strings (templates, scripts, buttons, labels, placeholders, dialogs, notifications, …).  
     • Vervang ze door `$customT('translation.key')`.  
     • Voeg ontbrekende keys toe aan **beide** `nl.json` en `en.json`.  
     • Gebruik consistente naamgeving, bv. `userMenu.version.current`, `auth.login.title`.
  2) Taalgedrag:
     • Fallback is altijd **Engels**.  
     • Nieuwe keys krijgen NL (app‑taal) en EN (fallback).
  3) Code:
     • In templates: `{{ $customT('key') }}`.  
     • In scripts (o.a. `$q.notify`): `$customT('key')`.  
     • Geen hardcoded UI‑strings achterlaten.  
  4) Bestanden:
     • `src/boot/i18n.ts` staat fallbackLocale op `'en'`.  
     • Update `src/i18n/nl.json` en `src/i18n/en.json` bij nieuwe keys.  
     • Reuse bestaande keys, niet dupliceren.  
  5) Validatie:
     • Scan gewijzigde files op harde strings en convert automatisch.  
     • Orden keys logisch per component/feature. 
Tags: @/i18n, @/boot/i18n, @/pages, @/components

---

# Changelog, version bump & tagging (conventional commits)
**Rule: Automatically update changelog, bump version, and tag releases**

Workflow bij commits:
  1) Haal de commit‑titel (eerste regel).  
  2) Parse type (feat, fix, chore, docs, refactor) volgens conventional commits.  
  3) Mapping:
     • feat → **minor**  
     • fix/chore/docs/refactor → **patch**  
     • `BREAKING CHANGE` of type `major` → **major**  
  4) Open `src/utils/changelog.ts` en voeg **bovenaan** toe:
     ```ts
     {
       version: "<semver>",
       date: "<YYYY-MM-DD>",
       type: "<major|minor|patch>",
       changes: ["<commit title>"]
     }
     ```
  5) Semver bump:
     • major: X+1.0.0  
     • minor: X.Y+1.0  
     • patch: X.Y.Z+1  
  6) Update `package.json` `"version"` exact gelijk aan changelog.  
  7) Maak Git‑tag `v<version>` en push die.  
  8) Behoud geldige TS in `src/utils/changelog.ts` en de `ChangelogEntry` interface.  
  9) Bestaat `src/utils/changelog.ts` niet? Aanmaken met `export const changelog: ChangelogEntry[] = [];`  
Constraints:
  • Nieuwe entries **altijd** op index 0.  
  • Oudere entries blijven onaangeroerd.  
  • Versies in changelog en `package.json` **in sync**.  
  • Datum in ISO‑formaat (YYYY‑MM‑DD).  
  • Altijd de tag pushen. 
Tags: @/utils/changelog.ts, package.json, Git tags

---

# PocketBase datum/tijd‑formaat (YYYY‑MM‑DD HH:mm:ss)
**Rule: Enforce PocketBase date/time format**

Context:
  • PocketBase velden/filters gebruiken het formaat `"YYYY-MM-DD HH:mm:ss"` (24u, geen ms, geen `T`/`Z`).  
  • Alle code die datums opslaat of filtert hanteert dit formaat.

Enforcement:
  1) Bij genereren/wijzigen van code met datums/tijden:
     • **Altijd** formatteren naar `"YYYY-MM-DD HH:mm:ss"`.  
     • Geen ISO strings of `T`/`Z`.  
     • Converteer met JS/TS of libs (bv. dayjs/date‑fns) naar exact formaat.
  2) Implementatiehints:
     ```ts
     const formatted = new Date().toISOString().replace('T', ' ').replace(/\..+/, '');
     // resultaat: "2025-08-13 12:34:56"
     ```
     of
     ```ts
     const d = new Date();
     const formatted = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
     ```
  3) PocketBase usage:
     • Elke `create()`, `update()`, en **filter** met datums gebruikt dit formaat.  
     • UI‑inputs (datetime pickers) moeten vóór opslag geconverteerd worden.
  4) Validatie:
     • Scan op ISO‑achtige strings (`T` of `Z`) en rewrite automatisch.  
     • Voorbeelden/tests tonen PocketBase‑compatibel formaat.
Constraints:
  • Altijd `"YYYY-MM-DD HH:mm:ss"`, 24‑uurs.  
  • Geen milliseconden, geen tijdzone‑markeringen.  
Tags: @/utils/datetime, PocketBase, date formatting

---

# ESLint‑enforcer (anti‑duplicatie)
Om de PB‑toegangspad‑regel te handhaven, moet ESLint directe imports verbieden:

```ts
// eslint.config.js – voeg toe aan rules
'no-restricted-imports': ['error', {
  paths: [
    {
      name: 'src/config/pocketbase',
      message: 'Gebruik usePocketbase() in UI/stores. Direct importeren is verboden.'
    }
  ]
}]