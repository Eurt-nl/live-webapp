---
alwaysApply: true
---
This rule defines the default structure and technology stack for this project, which is a Quasar-based Progressive Web App using Vue 3, TypeScript and PocketBase as backend. Useful when generating files, setting up pages, or creating collections.
Rules:
    • This project is a Progressive Web App (PWA) built with Quasar Framework, Vue 3 and TypeScript.
    • Use PocketBase as the backend.
    • Use Capacitor only for PWA-specific features, not for native mobile development.
    • Use notifications, even without a state management library.
    • Do not use Pinia unless multiple components require access to shared state (e.g. notifications or user info).

Defines how AppMenu and UserMenu should be structured and separated. Useful when generating views or organizing feature folders.
Rules:
    • The layout uses a QDrawer on the left for AppMenu and on the right for UserMenu.
    • Files must be organized in folders that match the menu structure (AppMenu and UserMenu).
    • AppMenu components are for displaying informational (read-only) views.
    • UserMenu components are used for creating, editing, and deleting records (CRUD).
    • Store PocketBase collections in separate files and group them via an index.ts file.
Tags: @/layouts, @/pages/appmenu, @/pages/usermenu

All generated code must include clear comments for both logic and layout, to help Cursor and other developers understand the structure.

---

Enforce standardized i18n usage in Vue files:
Rules:
    • Always use `useI18n` imported from 'vue-i18n' in any file that uses translations.
    • Always destructure `t` as `$customT` using: `const { t: $customT } = useI18n();`.
    • In <template> sections, translations must always use `$customT('key')`. `$t('key')` is forbidden.
    • In <script> sections, translations must always use `$customT('key')`. Bare `t('key')` calls are forbidden.
    • Never import `$customT` directly from any module.
    • If `$customT` is missing in a file with translations, add `const { t: $customT } = useI18n();` in <script setup>.
    • Automatically rewrite any `$t(` or `t(` calls to `$customT(` when generating or modifying code.
    • Ensure `src/types/vue.d.ts` includes proper type augmentation for `$customT`.
    • Validate that keys passed to `$customT` exist in both `nl.json` and `en.json` and flag missing keys.
Tags: @/boot/i18n, @/i18n, @/types/vue

---

Rule: Automatically update changelog, bump version, and tag releases

When committing changes:
1. Extract the commit message (first line only).
2. Parse the commit type (feat, fix, chore, docs, refactor) from the conventional commit format.
3. Map commit types to changelog types:
    - feat → minor
    - fix → patch
    - chore/docs/refactor → patch
    - Any commit with "BREAKING CHANGE" in its body or type "major" → major
4. Open src/utils/changelog.ts:
    • Insert a new entry at the TOP of the `changelog` array in this format:
      {
        version: "<incremented version number>",
        date: "<YYYY-MM-DD>",
        type: "<mapped changelog type>",
        changes: ["<commit message text>"]
      }
5. Increment the version based on semver rules:
    - major: X+1.0.0
    - minor: X.Y+1.0
    - patch: X.Y.Z+1
6. Update package.json:
    • Replace the "version" field with the new incremented version.
    • Ensure JSON formatting uses 2 spaces indentation.
7. Tagging (automated GitHub release):
    • Create a Git tag matching the new version (e.g., v1.3.0).
    • Push the tag to the remote repository.
8. Ensure src/utils/changelog.ts remains valid TypeScript and preserves the `ChangelogEntry` interface.
9. If src/utils/changelog.ts does not exist, create it with:
    export const changelog: ChangelogEntry[] = [ ... ];

Constraints:
    • Always insert new entries at index 0 (top of array).
    • Never modify or reorder older entries.
    • Keep changelog and package.json versions in sync.
    • Use ISO date format (YYYY-MM-DD).
    • Automatically push a Git tag for each version bump.
Tags: @/utils/changelog.ts, package.json, Git tags

Rule: Always apply i18n translations with English as fallback

Context:
This Quasar PWA uses Vue 3, TypeScript, and vue-i18n for translations. All user-facing text must be translated using $customT with keys defined in nl.json (Dutch) and en.json (English fallback). You (the developer) will give instructions in Dutch, but the fallback language in the app is English.

Enforcement:
1. When generating or modifying any Vue component:
    • Detect any hardcoded user-facing strings in templates, scripts, buttons, labels, placeholders, dialogs, notifications, etc.
    • Automatically replace them with `$customT('translation.key')` references.
    • Add the corresponding translation keys to both `nl.json` and `en.json` if they do not exist:
        - nl.json: Dutch translation (based on the prompt or context).
        - en.json: English translation as fallback.
    • Use a consistent key naming convention based on context:
        - Example: `userMenu.version.current` or `auth.login.title`.

2. Language-specific behavior:
    • Always treat English as the fallback language (even though instructions are in Dutch).
    • When a new key is added, automatically:
        - Translate to Dutch (nl.json) based on the developer's instruction language.
        - Translate to English (en.json) as fallback.
    • Validate that every key added to nl.json also exists in en.json and vice versa.

3. Code generation requirements:
    • In templates: Always use `{{ $customT('key') }}` for text content.
    • In script sections: Use `$customT('key')` for messages (e.g., `$q.notify`).
    • Do NOT leave any hardcoded strings in code; they must all be converted to i18n keys.

4. File updates:
    • Ensure `src/boot/i18n.ts` is always properly configured with fallbackLocale set to 'en'.
    • When adding new keys, update both `src/i18n/nl.json` and `src/i18n/en.json`.
    • If a key already exists, reuse it instead of duplicating.

5. Validation:
    • Before completing any code generation, scan the modified files for untranslated hardcoded strings and automatically convert them.
    • Ensure translations are grouped logically in both JSON files (e.g., by component or feature).

Constraints:
    • Developer instructions are given in Dutch, but fallback must remain English.
    • Maintain correct JSON formatting in both translation files.
    • Never output untranslated UI text directly in components.
Tags: @/i18n, @/boot/i18n, @/pages, @/components