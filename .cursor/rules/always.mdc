---
alwaysApply: true
---
This rule defines the default structure and technology stack for this project, which is a Quasar-based Progressive Web App using Vue 3, TypeScript and PocketBase as backend. Useful when generating files, setting up pages, or creating collections.
Rules:
    • This project is a Progressive Web App (PWA) built with Quasar Framework, Vue 3 and TypeScript.
    • Use PocketBase as the backend.
    • Use Capacitor only for PWA-specific features, not for native mobile development.
    • Use notifications, even without a state management library.
    • Do not use Pinia unless multiple components require access to shared state (e.g. notifications or user info).

Defines how AppMenu and UserMenu should be structured and separated. Useful when generating views or organizing feature folders.
Rules:
    • The layout uses a QDrawer on the left for AppMenu and on the right for UserMenu.
    • Files must be organized in folders that match the menu structure (AppMenu and UserMenu).
    • AppMenu components are for displaying informational (read-only) views.
    • UserMenu components are used for creating, editing, and deleting records (CRUD).
    • Store PocketBase collections in separate files and group them via an index.ts file.
Tags: @/layouts, @/pages/appmenu, @/pages/usermenu

All generated code must include clear comments for both logic and layout, to help Cursor and other developers understand the structure.

---

Enforce standardized i18n usage in Vue files:
Rules:
    • Always use `useI18n` imported from 'vue-i18n' in any file that uses translations.
    • Always destructure `t` as `$customT` using: `const { t: $customT } = useI18n();`.
    • In <template> sections, translations must always use `$customT('key')`. `$t('key')` is forbidden.
    • In <script> sections, translations must always use `$customT('key')`. Bare `t('key')` calls are forbidden.
    • Never import `$customT` directly from any module.
    • If `$customT` is missing in a file with translations, add `const { t: $customT } = useI18n();` in <script setup>.
    • Automatically rewrite any `$t(` or `t(` calls to `$customT(` when generating or modifying code.
    • Ensure `src/types/vue.d.ts` includes proper type augmentation for `$customT`.
    • Validate that keys passed to `$customT` exist in both `nl.json` and `en.json` and flag missing keys.
Tags: @/boot/i18n, @/i18n, @/types/vue

---

Rule: Automatically update changelog, bump version, and tag releases

When committing changes:
1. Extract the commit message (first line only).
2. Parse the commit type (feat, fix, chore, docs, refactor) from the conventional commit format.
3. Map commit types to changelog types:
    - feat → minor
    - fix → patch
    - chore/docs/refactor → patch
    - Any commit with "BREAKING CHANGE" in its body or type "major" → major
4. Open src/utils/changelog.ts:
    • Insert a new entry at the TOP of the `changelog` array in this format:
      {
        version: "<incremented version number>",
        date: "<YYYY-MM-DD>",
        type: "<mapped changelog type>",
        changes: ["<commit message text>"]
      }
5. Increment the version based on semver rules:
    - major: X+1.0.0
    - minor: X.Y+1.0
    - patch: X.Y.Z+1
6. Update package.json:
    • Replace the "version" field with the new incremented version.
    • Ensure JSON formatting uses 2 spaces indentation.
7. Tagging (automated GitHub release):
    • Create a Git tag matching the new version (e.g., v1.3.0).
    • Push the tag to the remote repository.
8. Ensure src/utils/changelog.ts remains valid TypeScript and preserves the `ChangelogEntry` interface.
9. If src/utils/changelog.ts does not exist, create it with:
    export const changelog: ChangelogEntry[] = [ ... ];

Constraints:
    • Always insert new entries at index 0 (top of array).
    • Never modify or reorder older entries.
    • Keep changelog and package.json versions in sync.
    • Use ISO date format (YYYY-MM-DD).
    • Automatically push a Git tag for each version bump.
Tags: @/utils/changelog.ts, package.json, Git tags